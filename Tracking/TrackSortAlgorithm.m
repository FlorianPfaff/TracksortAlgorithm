function [trackHistory, env] = TrackSortAlgorithm(borders, optionalArgs)
% Perform tracking and save results in track history. Can also be called
% from GUI to directly see output. Use plotHistory to see history in GUI
% and step through it, once it has been calculated
% Attention! Use with Matlab 2021a! Syntax:
% tracksortAlgorithm(borders, predictFrom = x, predictTo = y,...)
%
% Parameters:
%   borders (2 x 2)
%       Be very careful when setting these parameters. In the following,
%       beginning means minimum coordinate and end means maximum
%       coordinate.
%       borders(1,1) describes the beginning of the observable area orthogonal to
%       the transport direction
%       borders(1,2) describes the end of the observable area orthogonal to
%       the transport direction
%       borders(2,1) describes the beginning of the observable area along
%       the transport direction
%       borders(2,2) describes the end of the observable area along
%       the transport direction
%   predictFrom (scalar)
%       Coordinate along the transport direction after which the prediction
%       is initiated
%   predictTo (scalar)
%       Coorindate along the transport direction to which we predict. This
%       must be higher than predictFrom
%   allParam (struct)
%       Struct describing all parameters for the algorithm. Use
%       getDefaultParam to generate parameters
%   path (string)
%       Path at which csv data and images are stored (only for real data, empty otherwise)
%   midpointMatrix (2 x #maxTracks x #timeSteps tensor)
%       Midpoints.
%       midpointMatrix(1,:,:) contains coordinates orthogonal to the
%       transport direction.
%       midpointMatrix(2,:,:) contains coordinates along the
%       transport direction.
%   orientationMatrix (#maxTracks x #timeSteps matrix)
%       Orientation measurements.
%   visualClassificationMatrix (#features x #maxTracks x #timeSteps tensor)
%       Visual features given as a vector.
% Returns:
%   trackHistory (struct array)
%       Information about all tracks that were generated by the tracking.
%       See information about the struct in the definition below
%
% @author Florian Pfaff
% @date 2014-2021
arguments
    borders (2, 2) double
    optionalArgs.predictFrom (1, 1) double = 0.7 * borders(end)
    optionalArgs.predictTo (1, 1) double = 0.9 * borders(end)
    optionalArgs.allParam struct = getDefaultParam()
    optionalArgs.path string = strings(0)
    optionalArgs.midpointMatrix (2, :, :) double = zeros(2, 0, 0)
    optionalArgs.orientationMatrix (:, :) double = zeros(0, 0)
    optionalArgs.visualClassificationMatrix (:, :, :) double = zeros(0, 0, 0)
end
% Repack arguments
allParam = optionalArgs.allParam;
allParam.general.predictFrom = optionalArgs.predictFrom;
allParam.general.predictTo = optionalArgs.predictTo;
allParam.general.path = optionalArgs.path;
midpointMatrix = optionalArgs.midpointMatrix;
orientationMatrix = optionalArgs.orientationMatrix;
visualClassificationMatrix = optionalArgs.visualClassificationMatrix;
path = optionalArgs.path;

if isempty(allParam)
    error('Do not pass an empty struct as parameters.');
end
if isempty(midpointMatrix) && (~isfield(allParam, 'live') || ~allParam.live.enabled)
    assert(~isempty(path) && exist(path, 'file') > 0, 'Need to provide either midpoint matrix or path to file.');
    if exist(path, 'dir') == 7
        csvPath = fullfile(path, 'data.csv');
    else
        csvPath = path;
    end
    [numberOfMidpoints, midpointMatrix] = readIOSBData(csvPath);
elseif allParam.live.enabled
    assert(isempty(midpointMatrix) && isempty(path), ...
        'Cannot pass midpoint matrix or csv file in live mode! Data is read in at each time step.');
else
    assert(~ismatrix(midpointMatrix), 'Please use new file format.');
    numberOfMidpoints = squeeze(sum(~isnan(midpointMatrix(1, :, :)), 2));
end
delegation_to_draw = allParam.plot.delegation_to_draw;
handles = allParam.plot.handles;
hObject = allParam.plot.hObject;

% Format of midpoint matrix: 1st dim: coordinate, 2nd dim: particle, 3rd dim: time step
if ~allParam.live.enabled && ismatrix(midpointMatrix) % Convert if old format
    warning('Please use new file format.');
    midpointMatrix = reshape(midpointMatrix', [2, size(midpointMatrix, 2) / 2, size(midpointMatrix, 1)]);
end
if ~allParam.live.enabled
    % Rotate scenario
    [midpointMatrix, borders] = rotateScenario(midpointMatrix, borders, allParam.general.rotateBy);
end
if allParam.association.useOrientation && isempty(orientationMatrix)
    warning('Cannot use orientation for the association as no orientation measurements were given.');
    allParam.association.useOrientation = false;
end

% Generate Q-matrix
if isfield(allParam.prediction, 'QtoScale') && isfield(allParam.prediction, 'S')
    assert(~isfield(allParam.prediction, 'Q'), ...
        'Use the powder spectral density S to scale the system uncertainty. Remove field QtoScale if you really want to set Q manually.');
    allParam.prediction.Q = allParam.prediction.S * allParam.prediction.QtoScale;
end

% Validate additional parameters
if ~allParam.live.enabled
    validateParams(allParam, borders, midpointMatrix);
else
    validateParams(allParam, borders);
end
% Approximate noises for filter and determine VM approx for log-likelihood
% method
if exist('VMDistribution', 'class') % Only do if libDirectional is installed
    allParam = adjustOrientationParams(allParam);
end

generalParam = allParam.general;
initialParam = allParam.initial;
predictionParam = allParam.prediction;
measParam = allParam.meas;
associationParam = allParam.association;
scoreParam = allParam.score;

edge = [borders(1, 2), allParam.general.predictTo];
lastHundredVelocities = NaN(1, 100);

%% Intialize history and allTracks as empty
trackHistory = repmat( ... % Initialize trackHistory as empty struct
    struct('Posterior', [], ... % All posterior estimates (measurement of time step is included)
    'RawMeasurements', [], ... % All measurements that were used of this track (useful, e.g., for motion-based classification)
    'RawOrientations', [], ... % All orientations that were used of this track (useful, e.g., for motion-based classification)
    'MeasIndex', [], ... % Index in this time step in midpointmatrix (can be used for evaluation if a mapping of midpoint to track ID is given)
    'Prediction', [], ... % All predictions (not integrating the measurement of the current time step)
    'PredictedX', NaN, 'LinePredictedX', NaN, ...
    'LastAngle', NaN, 'LastVelocity', NaN, 'StartTime', NaN, 'EndTime', NaN, 'LastSeenTime', NaN, 'TrueIntersection', NaN, ...
    'Lengths', [], 'Widths', [], 'PredictedIntersectionTime', NaN, 'LinepredictedIntersectionTime', NaN, ...
    'OrientationEstimates', [], 'VisualClassifications', []), ...
    [1, 0]);

allTracks = struct('ID', {}, 'Position', {}, ...
    'PositionCov', {}, ...
    'Angle', {}, 'AngleVar', {}, ...
    'Velocity', {}, 'VelocityVar', {}, ...
    'FullState', {}, 'FullStateCov', {}, ... % For integrating const acc
    'TrackScore', {}, ...
    'Length', [], 'Width', [], ...
    'OrientationFilter', {});

haveCheckedVelocities = false;
currVelocityVar = initialParam.VelocityVar;
currVelocityGuess = initialParam.VelocityGuess;
nextID = 1;

if ~allParam.live.enabled
    firstRelevantFrame = find(numberOfMidpoints, 1, 'first'); % Do not need to start if no measurements were ever obtained
    cumNumberOfMidpoints = cumsum(numberOfMidpoints);
    startAt = max(generalParam.startFrameNo, firstRelevantFrame);
    endAt = min(generalParam.endFrameNo, size(numberOfMidpoints, 1));
else
    startAt = 1;
    % We do not want it to stop. Use double to prevent index from becoming
    % int, which can cause problems.
    endAt = double(intmax);
end
assert(startAt < endAt, 'Last frame before first relevant frame. This is either an error in the config or no particles appear until endFrame.');
dispstat('', 'init');
for t = startAt:endAt
    % Set new mesurements
    if ~allParam.live.enabled
        % If not live, take from matrix
        currNumberOfMeasurements = numberOfMidpoints(t);
        currMeasurements = struct('midpoints', midpointMatrix(:, 1:currNumberOfMeasurements, t));
        if ~isempty(orientationMatrix)
            currMeasurements.orientations = orientationMatrix(1:currNumberOfMeasurements, t);
        end
        if ~isempty(visualClassificationMatrix) % Visual classification can be given as a noFeatures x measurements x time matrix
            currMeasurements.visualClassifications = visualClassificationMatrix(:, 1:currNumberOfMeasurements, t);
        end
        % Print out status
        if mod(t, 50) == 0
            dispstat(sprintf('At time step %d of %d', t, endAt));
        end
    else
        terminate = waitForNextTimeStep(t, allParam.live);
        if terminate
            disp('Ending live mode.');
            break
        end
        fprintf('Processing time step %d\n', t);
        [currMeasurements, currNumberOfMeasurements] = readMidpointsLive(allParam.live.DEMOutput);
        if currNumberOfMeasurements == 0 % Throw warning to be able to detect when this occurred
            warning('LiveMode:NoMeas', 'No measurements were obtained at time step %5.5G.', t*allParam.live.timeStepMultiplier);
        end
    end
    % Check again because not checked in beginning in live mode
    assert(isempty(currMeasurements.midpoints) || all(all((borders(:, 1) <= currMeasurements.midpoints & currMeasurements.midpoints <= borders(:, 2)))), 'Observed particles outside of borders. Check arguments.');

    if ~allParam.live.enabled && ((t >= (firstRelevantFrame + 10)))
        if numel(trackHistory) > (cumNumberOfMidpoints(t) / 4) && numel(trackHistory) <= (cumNumberOfMidpoints(t) / 4)
            warning('TrackSortAlgorithm:BadParameters', ...
                'The number of tracks is larger than a fouth of all measurements obtained so far. This implies that the parameters are chosen badly.');
        elseif numel(trackHistory) > (cumNumberOfMidpoints(t) / 2)
            error('TrackSortAlgorithm:VeryBadParameters', ...
                'The number of tracks is larger than a half of all measurements obtained so far. Parameters are so bad it does not make sense to continue.');
        end
    end
    % If we have hundred velocities: Test if the orientation is as we
    % expect it: Particles should travel from down to up. Otherwise, some
    % stuff will not work.
    if ~haveCheckedVelocities && ~any(isnan(lastHundredVelocities))
        allMovements = zeros(2, 0);
        for i = 1:numel(trackHistory)
            currTrackMovements = reshape(trackHistory(i).Posterior(~isnan(trackHistory(i).Posterior)), 2, []);
            allMovements = [allMovements, diff(currTrackMovements, 1, 2)]; %#ok<AGROW>
        end
        medianMovement = median(allMovements, 2);
        if abs(medianMovement(1)) > abs(medianMovement(2))
            warning(['The scenario is oriented in a way that may impede the performance of the', ...
                ' association as regions of low and high appearance/disapperanceprobability will be wrong.', ...
                ' Furthermore, predictions will not work.']);
        end
        haveCheckedVelocities = true;
    end

    if isempty(allTracks) % No tracks exist, all have to be initialized
        [allTracks, trackHistory, nextID] = deleteAddTracks(t, ...
            allTracks, trackHistory, 1:currNumberOfMeasurements, ... % All measurements are new
            [], initialParam, scoreParam, predictionParam, nextID, currVelocityGuess, currVelocityVar, ...
            currMeasurements);
        continue % No prediction and update possible then
    end
    currMatrixDimension = length(allTracks) + associationParam.maxNewMeas;
    %ensure that there are not too many measurements to handle
    assert(currNumberOfMeasurements <= currMatrixDimension);
    %ensure that ratio of tracks and measurements is reasonable
    assert(abs(currNumberOfMeasurements-length(allTracks)) < associationParam.maxNewMeas*2);

    %% Prediction
    allTracksBeforePredict = allTracks;
    allTracks = predict(predictionParam, allTracks);

    %% Association
    [bestPerm, unobservedTrackList, newTrackMeasurements] = ...
        calcLikelihoodsAndAssociate(allTracks, borders, currMeasurements, ...
        currNumberOfMeasurements, currVelocityGuess, ...
        associationParam, measParam, predictionParam);
    % Update track scores
    [allTracks, deleteTrackList] = updateTrackScores(allTracks, unobservedTrackList, scoreParam);

    %% Update persisting tracks using measurements (GNN/GAL)
    [allTracks, trackHistory, lastHundredVelocities] = ...
        updateGAL(t, measParam, allTracks, trackHistory, ...
        bestPerm, allTracksBeforePredict, lastHundredVelocities, deleteTrackList, ...
        unobservedTrackList, currMeasurements);

    %% Update velocity guess
    if (t - generalParam.startFrameNo) > 10 && all(~isnan(lastHundredVelocities)) % If we have 100 velocities, use better velocity guess
        currVelocityGuess = [median(lastHundredVelocities); 0];
        currVelocityVar = initialParam.refinedVelocityVar;
    else % If we do not have 100 velocities, use initial guess
        currVelocityGuess = initialParam.VelocityGuess;
        currVelocityVar = initialParam.VelocityVar;
    end

    %% generate prediction for pos at separation mechanism
    [trackHistory] = predictToSeparation(t, allTracks, trackHistory, ...
        deleteTrackList, edge, allParam.general.predictFrom, currVelocityGuess, predictionParam);

    %% delete and add new tracks
    [allTracks, trackHistory, nextID] = deleteAddTracks(t, ...
        allTracks, trackHistory, newTrackMeasurements, deleteTrackList, ...
        initialParam, scoreParam, predictionParam, nextID, currVelocityGuess, currVelocityVar, ...
        currMeasurements);

    if mod(t, 100) == 0 && (numel(trackHistory) > (2 * numel(allTracks))) && numel(trackHistory) > 15
        spread = max([trackHistory.Posterior], [], 2) - min([trackHistory.Posterior], [], 2);
        if any(spread < (diff(borders, 1, 2) / 2))
            warning('TrackSortAlgorithm:TracksShortForCurrentBorders', 'Tracks do not even span over half of the observable area. Verify parameters');
        end
    end

    % Output
    if allParam.live.enabled
        writeNozzleControl(trackHistory, allParam.live);
        writeDebugLiveMode(trackHistory, allParam.live);
    elseif isempty(delegation_to_draw) % Output to console if no GUI active
        if mod(t, generalParam.plotEveryNthStep) == 0
            fprintf('Processed time step %d\n', t);
        end
    elseif ~delegation_to_draw(t, trackHistory, handles, hObject)
        break
    end
end
deleteTrackList = 1:length(allTracks);
[~, trackHistory] = deleteAddTracks(t, allTracks, trackHistory, ...
    [], deleteTrackList, ...
    initialParam, scoreParam, predictionParam, nextID, [], [], ...
    struct('midpoints', Inf(2, 1), 'orientations', Inf)); % Must pass dummy data

tracksLengths = cellfun(@length, {trackHistory.Posterior});
if generalParam.startFrameNo - t > 30 && min(tracksLengths) < (0.5 * (borders(2, 2) / initialParam.VelocityGuess(1)))
    warning('Some tracks are apparently short.')
elseif max(tracksLengths) > (2 * (borders(2, 2) / initialParam.VelocityGuess(1)))
    warning('Tracks that are longer than expected occurred.')
end
env = struct('predictionOnlyStart', allParam.general.predictFrom, 'Pred_edge', allParam.general.predictTo, 'resolution', borders, 'imagePath', '', 'rotateBy', allParam.general.rotateBy);
end
